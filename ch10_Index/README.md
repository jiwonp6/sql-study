# ◎ 데이터베이스 설계

## * 인덱스 (Index)
- DB에서 검색을 빠르게 하기 위해 사용되는 데이터 구조
- 하나 이상의 컬럼(속성)에 적용하여 해당 열을 기준으로 데이터를 빠르게 검색
- 일반적으로 B-Tree 데이터 구조를 사용
- 성능 최적화, 쿼리 최적화
   - 실제 데이터베이스에서 인덱스 튜닝을 하면 즉각적으로 성능 효과를 보고, 빠른 응답속도를 얻어낼 수 있음
- 인덱스 생성, 유지 관리에 자원 소모
   - 데이터 조작 작업(INSERT, UPDATE, DELETE) 작업 시 추가 작업이 필요함
   - 데이터가 변경될 때마다 인덱스도 변경되어야 함
   - 조작(쓰기) 작업이 많은 DB에서는 오히려 인덱스의 성능이 감소

### 클러스터형 인덱스와 보조 인덱스
1. 클러스터 인덱스 (Clustered Index)
   - 테이블 생성 시 *기본 키*를 지정하면 기본키에 대한 클러스터 인덱스를 생성
   - *물리적 데이터베이스*가 클러스터 인덱스를 기준으로 정렬되어 저장
   - *한 테이블 당 하나*만 생성 가능
2. 보조 인덱스 (Secondary Index)
   - 데이터의 물리적 정렬 순서를 변경하지 않음
   - 클러스터 인덱스와는 별개로 하나 이상의 컬럼에 대한 참조 인덱스 제공
   - 데이터에 포인터를 사용해서 간접적으로 접근
   - 하나의 테이블에는 여러 개의 보조인덱스가 존재 가능

### MySQL에서 자동으로 생성되는 인덱스
   - 기본 키 인덱스
      - 테이블의 고유 식별, 클러스터 인덱스가 생성
   - 외래 키 인덱스
      - 외래 키 제약조건이 있는 컬럼을 기준으로 생성
      - 참조 무결성, 조인 연산 속도 향상을 위해 자동 생성
   - 유니크 인덱스
      - 고유 제약 조건을 설정하면 자동으로 인덱스 생성

   1. PRIMARY KEY로 지정한 열은 클러스터형 인덱스가 생성
   2. UNIQUE NOT NULL로 지정한 열은 클러스터형 인덱스가 생성
   3. UNIQUE로 지정한 열은 보조 인덱스가 생성
   4. FOREIGN KEY로 지정한 열 보조 인덱스가 생성
   5. PRIMARY KEY와 UNIQUE NOT NULL로 지정한 열이 있으면 기본 키 지정한 열에 우선하여 클러스터형 인덱스 생성
   6. 물리적 DB는 PRIMARY KEY 지정한 열로 데이터 오름차순 정렬

### 인덱스의 내부작동 BTREE
- 데이터베이스 테이블을 효율적으로 관리하는 인덱스 자료구조
- 기본 개념 정의
   1. 노드(Node) : 트리의 기본 단위
   2. 키(Key) : 노드 내에서 데이터를 정렬하는데 사용되는 요소
   3. 루트 노드(Root Node) : 트리의 최상위 노드
   4. 리프 노드(Leaf Node) : 트리의 가장 하단에 위치하는 노드들(실제 데이터의 주소나 데이터 자체 포함 가능)
   5. 내부 노드(Internal Node) : 루트 노드와 리프 노드 사이에 있는 노드
- ![B-tree 그림](../ch10_Index/b-tree.png)
- B Tree의 파라미터
   1. M : 각 노드의 최대 자녀 수 (최대 M개의 자녀를 가질 수 있는 M차 B tree)
   2. M-1 : 각 노드의 최대 Key 수
   3. M/2 : 각 노드의 최소 자녀 노드 수
   4. (M/2)-1 : 각 노드의 최소 Key 수
- 인터널 노드의 Key 수 x개 -> 자녀 노드 수 (x + 1)개
- N차 B Tree와는 별개로 인터널 노드는 반드시 최소 2개의 자녀를 가짐
- 항상 Leaf 노드에 삽입
- 노드가 넘치면 가운데 Key를 기준으로, 좌우 Key를 분할하고 가운데 Key가 승진
- 모든 leaf 노드는 같은 레벨에 존재

- B Tree의 이점
   - 트리 깊이가 낮다 
      - 각 노드에서 많은 수의 자식을 가질 수 있기 때문에 트리 깊이가 낮아짐 (트리 깊이 = 디스크 접근 횟수)
   - 디스크 I/O 최적화 
      - 보조기억장치의 디스크 블록 크기와 일치하도록 노드 크기를 설정할 수 있음
      - 한 번의 읽기/쓰기 노드(페이지) 하나를 전체로 읽거나 쓸 수 있음
   - 분할 및 병합이 효율적임
      - 노드(페이지)가 가득찼을 때 분할, 병합되는 효율적인 알고리즘을 가지고 있음

### 인덱스 기본 문법
   ```sql
   -- 인덱스 생성
   CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼이름);

   -- 복합 인덱스 생성
   CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼이름1, 컬럼이름2, ...);

   -- 고유 인덱스 생성 (중복된 값 허용 안되는 인덱스)
   CREATE UNIQUE INDEX 인덱스이름 ON 테이블이름 (컬럼이름);

   -- 인덱스 삭제
   DROP INDEX 인덱스이름 ON 테이블이름;

   -- 인덱스 정보조회
   SHOW INDEX FROM 테이블명;

   -- 쿼리 실행계획 확인
   EXPLAIN SELECT 컬럼명 FROM 테이블명 WHERE 조건;

   -- 인덱스 수정
   ALTER INDEX 이전인덱스명 RENAME TO 새인덱스명;

   -- 인덱스 컬럼 추가
   ALTER INDEX 인덱스명 ADD 새컬럼명;

   -- 인덱스 컬럼 제거
   ALTER INDEX 인덱스명 DROP 컬럼명;

   -- 테이블 업데이트 및 분석
   ANALYZE TABLE 테이블명;

   -- 테이블 상태 확인하기
   SHOW TABLE STATUS;
   SHOW TABLE STATUS LIKE '테이블명';
   ```

### 인덱스 성능 향상
   1. 인덱스는 열(컬럼) 단위로 생성
   2. WHERE 절에서 자주 사용되는 컬럼에 인덱스를 생성
   3. 자주 정렬(SORT)되거나 그룹화(GROUP BY)가 필요한 쿼리에 인덱스 생성
   4. 다른 테이블과 자주 조인되는 컬럼에 인덱스 사용
   5. 특정 범위로 검색하는 쿼리에 인덱스를 사용
   6. 고유성을 유지해야 하는 필드에 인덱스를 사용
   7. 사용하지 않는 인덱스는 제거하는 것이 성능 향상
   8. 쓰기 작업은 적고, 읽기 작업이 많은 테이블에 인덱스 생성

- 인덱스를 사용하면 성능 더 저하되는 경우
   1. 데이터가 자주 변경되는 테이블 (쓰기 작업이 많은 테이블)
      - 데이터 변경 작업이 일어날 때마다 인덱스들도 같이 변경 작업 필요
   2. 데이터 양이 적은 집합
      - 데이터가 적을 경우 오히려 성능을 저하시킬 수 있음
   3. 고유값의 수가 낮은 컬럼
      - 인덱스를 설정해도 거의 효과가 없음
   4. 쿼리가 대부분의 테이블 데이터를 반환해야 할 경우
      - 전체 데이터를 반환해야 한다면 Full Table Scan이 유리
   5. 데이터 크기가 큰 필드(컬럼) (BLOB, TEXT)
      - 크기가 큰 이진 파일이나, 내용이 매우 긴 텍스트 인덱스는 비효율적